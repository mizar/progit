# 使い始める #

この章は、Gitを使い始めることに関して説明します。はじめに幾つかのバージョン管理システム背景を紹介し、その後Gitをあなたのシステムで稼動させる方法を解説し、最後にGitで作業を始めるための設定について説明します。この章の終わりには、なぜGitが広まっているか、なぜGitを使うべきなのか理解し、Gitを利用するための準備が全て整っているでしょう。

## バージョン管理に関して ##

バージョン管理とはいったい何で、なぜそれに注目する必要があるのでしょうか。
バージョン管理とは、変更を一つのファイルまたはファイルの集合の変化の過程を記録するシステムで、後々特定バージョンを呼び出すことが目的です。現実にはコンピューター上のほとんどあらゆるファイルのタイプでバージョン管理を行なう事ができますが、本書の中の例ではバージョン管理されるファイルとしてソフトウェアのソースコードを利用します。

もしあなたがグラフィックスやウェブデザイナーであり、画像もしくはレイアウトの各バージョンを管理したいのであれば、バージョン管理システム（VCS）の利用は賢い選択となるでしょう。それはファイルやプロジェクト丸ごとを以前の状態に戻し、それらの変化を比較し、問題となっている対象を最後に修正したのが誰であるか、誰がいつその問題の原因を作ってしまったか、把握するのを手伝い、それ以上をも可能にします。また、VCSを使うということは失敗したりファイルを失ったとしても、簡単に復元させることができることを意味します。加えて、それら全てをとても僅かな諸経費で得ることができます。

### ローカル・バージョン管理システム ###

バージョン管理の手法として多くの人に利用されているのは、ファイルを別ディレクトリにコピーするという方法です(賢い方はディレクトリを時系列に分けているかも知れません)。この方法は単純明快であることから非常に一般的ですが、同時に失敗も引き起しがちです。現在のディレクトリを忘れてしまい、間違ったファイルに書き込んでしまったり、意図しないファイルをコピーしてしまいます。

この問題を解決するためプログラマーたちはローカルVCSを開発しました。当時のそれはファイルへの変更全てをリビジョン管理下に置く単純なデータベースによるものでした(図1-1)。

Insert 18333fig0101.png 
図1-1. ローカル・バージョン管理図

もっとも有名なVCSツールの一つにRCSと呼ばれるシステムがありました。これは今日でも多くのコンピュータと共に配布されています。人気のMac OS Xでさえも、開発ツールをインストールするとRCSコマンドが含まれています。このツールは基本的に、変更から変更を特別なディスク・フォーマットのパッチ・セット(これはファイルとは異なります)に記録して動きます. これはパッチに追加された全ての時点のファイルを再生成することができます.

### 集中バージョン管理システム ###

<<<<<<< HEAD
次に人々が直面した問題が、他システムを使う開発者たちとの共同作業です。これを解決するため、集中型バージョン管理システム(CVCS)が開発されました。CVSやSubversion、PerforceといったCVCSは、一つのサーバで全てのファイルを管理し、
複数のクライアントがサーバからファイルをチェックアウトします。この手法は長年バージョン管理のスタンダードでした(図1-2)。

Insert 18333fig0102.png 
図1-2. 集中型バージョン管理図

CVCSにはローカルVCS以上に多くの利点があります。例えば、プロジェクトに所属しているほかの人が何をしているのか誰でもある程度正確に把握できます。また管理者の立場からは、各クライアントごとのローカルデータベースを処理するよりCVCSで管理する方がはるかに容易で、それぞれの権限を肌理細やかに管理することができます。

しかし, CVCS にはいくつか深刻な欠点があります. 最も明らかなのは集中型サーバで発生する単一障害点(SPOF)です. サーバが1時間でもダウンすれば, その間は誰ともコラボレーションできませんし, 作業中全ての変更をバージョン管理することもできません. 中央データベースのハードディスクに破損が生じ, 適切にバックアップされていなかった場合, 個々のローカルコンピュータが持つスナップショット以外のプロジェクト全体の変更履歴を失うことになります. ローカル VCS も同じ問題に脅かされています. つまり一カ所でプロジェクト全体の履歴を失えば全てを失うリスクがあるということです.

### 分散型バージョン管理システム ###

ここから分散型バージョン管理システム(以降 DVCS と呼ぶ)に入っていきましょう. DVCS (Git, Mercurial, Bazaar, Darcs 等々)では, クライアントはファイルの最新スナップショットをチェックアウトするだけではありません. リポジトリ全体をミラーリングします. 故にどのサーバがダウンしても, そのサーバを介してコラボレーションしていたシステムは, どれか一つのクライアントのリポジトリからサーバ復旧の為バックアップをコピーすることができます. 全てのチェックアウトは全データの完全バックアップなのです(図1-3).

Insert 18333fig0103.png 
図1-3. 分散型バージョン管理システムの図

加えて, これら DVCS の多くが, 連携する複数のリモート・リポジトリを持ちながら上手く機能します. おかげで同じプロジェクトの中で, 様々の方法を一度に異なった集団でコラボレーションさせることができるのです. DVCS は 集中型システムでは不可能だったいくつかの作業手順も可能にします. 例えば階層型モデルがそうです.

## Git の簡単な歴史 ##

人生における多くの素晴らしい出来事のように, Git はわずかな創造的破壊と情熱的論争から始まりました. Linux カーネルは非常に巨大なオープンソース・ソフトウェア・プロジェクトです. Linux カーネル保守の生涯のほとんど(1991-2002年)で, ソフトウェアへの変更はパッチとして配布されファイルに保管されました. 2002年, Linux カーネル・プロジェクトはプロプライエタリの DVCS である BitKeeper を使い始めました.

2005年, Linux カーネルの開発コミュニティと BitKeeper 開発会社との関係が砕けました. BitKeeper の無償利用が取り消されたのです. これは Linux 開発コミュニティ(と特に Linux 開発者 Linus Torvalds)に, BitKeeper から得た教訓を踏まえた専用のツール開発を促しました. 新たなシステムのゴールにすえられたもののうちいくつかは以下の通りです:

*	スピード
*	シンプル・デザイン
*	ノンリニア開発(数千の並列ブランチ)への強力なサポート
*	完全な分散型
*	Linux カーネルのような大規模プロジェクトを(スピードとデータサイズで)効率的に処理可能

2005年に誕生してから, Git はその使いやすさとこれら基本品質を保持しながら発展しています. 驚くほど早く, 大規模プロジェクトでとても効率的で, 驚くべきブランチ・システムをノンリニア開発に与えています(第3章参照).

## Git の基本 ##

では, 小さな容器の中で Git は何なのでしょう. これは理解すべき重要な部分です. Git とは何か, そして基本的動作を理解すれば, Git を効果的に使うのがより簡単になるはずです. Git 学習のため, Subversion や Perforce など他の VCS は忘れて下さい. これはこのツールを使うときの混乱を避けるのに役立ちます. Git の情報の格納方法と考え方は他 VCS と大きく異なります. そうでありながらユーザインタフェースはかなり似ています. これら違いを理解することが使用時の混乱を防ぎます.

### スナップショット != 相違 ###

Git と他の VCS (Subversion とその類を含む)の代表的な相違は, Git のデータについての考え方です. 概念的に, 他システムのほとんどが情報をファイルごとの変更のリストとして格納します. これらシステム(CVS, Subversion, Perforce, Bazaar 等々)はシステムが保持するファイル群と各ファイルの時間ごとの変更を考えます. 図1-4に表しました.

Insert 18333fig0104.png 
図1-4. 他システムはデータを各ファイルの元となるバージョンへの変更として格納します.

Git は考え方もデータ格納方法も上記とは異なります. 代わりに Git は データをミニ・ファイルシステムのスナップショット群のように考えます. コミットする度, Git でプロジェクトの状態を保存する度, 全てのファイルがどのように見えるか, その瞬間の写真を撮るのです. そしてそのスナップショットへの参照を格納します. 効果的にするため, そのファイルは変更されません. Git は2度とそのファイルを格納しません. ちょうど以前の識別可能な格納済みファイルへのリンクのようなものです. Git はデータを図1-5のように考えます.

Insert 18333fig0105.png 
図1-5. Git は時間とともにプロジェクトのスナップショットをデータとして格納します.

これは Git と ほぼそれ以外全ての VCS における相違です.  Git はほぼ全ての面で, 過去の世代からコピーされたほとんどのバージョン管理システムを見直しています. これは Git をミニ・ファイルシステムとその上に組み上げられた驚くほど力強いツールとしています. ただの VCS 以上のものにです. 第3章, Git ブランチを扱う時, データに対するこの考え方で得られる利益を見出せるでしょう.

### ほぼ全ての操作はローカル ###

Git のほとんどの操作はローカルファイルと操作のためのリソースだけで十分です. 基本的にネットワーク上の他コンピュータから情報は必要ありません. ほとんどの操作を呼び出し時間のオーバヘッドがあるネットワークで行う集中型バージョン管理に慣れていると, この面で Git は, この世のものでない, 神に祝福をされたスピードだと思えるでしょう. これはプロジェクト全体の履歴を目前のコンピュータが全て持っているからに他なりません. ほとんどの操作が一瞬に感じられます.

例えば, プロジェクトの履歴を参照するのに, Git はサーバにアクセスして履歴を取得する必要がありません. 単純にローカルデータベースを直接参照します. つまりプロジェクトの履歴をほぼ即座に確認できます. 現バージョンのファイルと1ヶ月前の変更を確認したければ, Git は1ヶ月前のファイルを検索しローカルで相違の確認が出来ます. サーバに相違の確認を問い合わせる必要も古いバージョンをサーバから入手してローカルで確認する手間もありません.

つまるところ, オフラインや VPN に接続していないコンピュータで何も出来ないわけではありません. 飛行機や電車で作業したい場合, どこかでネットワーク接続するまでコミットを続けられます. もし自宅で VPN クライアントが正常に動作しなくても, 作業は続けられます. 多くの他システムでこれは不可能か現実的ではありません. Perforce では例えばネットワーク接続がないと大したことができません. Subversion と CVS ではファイルの編集は出来ますが変更のコミットをデータベースに反映できません(データベースに接続できないので). これは大きな問題ではないかも知れません. しかし Git のもたらす大きな利点には驚いたのではないでしょうか.

### Git は誠実です ###

Git のリソースは全て, 格納前と参照前にチェックサムが実施されます. つまり Git に感知されずにファイルやディレクトリに変更を加えることは不可能です. これは根本的な機能として組み込まれ, Git の哲学にもなっています. 情報伝達を失うこともファイルを破壊することも, Git 抜きでは不可能です.

Git の用いるこのチェックサム・メカニズムは SHA-1 ハッシュです. これは40文字からなる16進数(0-9 と a-f)と ファイルの中身や Git のディレクトリ構造を計算した物を基本としています. SHA-1 ハッシュは下記のようなものです:

	24b9da6552252987aa493b52f8696cd6d3b00373

Git の中ではこのようなハッシュをいたるところで目にするでしょう. 実際, Git は全てをファイル名でなく, ファイルの内容をハッシュ値でデータベースに記録します.

### Git は通常データだけを追加します ###

Git で行動するとき, それらのほとんど全ては Git データベースへデータを追加するだけです. する事全部を元に戻せないかどんな方法でもデータを消去するシステムを手に入れるのはとても大変です. 何故ならどんな VCS でも, まだコミットしていない変更を失ったり台無しにするかも知れないのです. しかし Git にスナップショットをコミットした後では, 失うのは非常に難しく, 特に定期的にデータベースを他のリポジトリにプッシュしている場合は尚更です.

事を深刻なまでに台無しにする危険抜きで実験できるのを知っているので, これは Git の使用を喜びに変えてくれます. Git がどのように自身のデータを格納し失われたかに見えるデータを復旧するかのより多くの熟慮された観点は, 第9章の“Under the Covers”をご覧下さい.

### 3つの状態 ###

今, 注目して下さい. 残りの学習過程をすらすらと行きたいならこれは Git について覚える主なことです. Git はファイルが属せる主な3つの状態があります. コミット, 修正, ステージです. コミットは, データは安全にローカルデータベースに格納されたという意味です. 修正は, ファイルを変更したがまだデータベースにコミットされていないという意味です. ステージは, 次のコミット・スナップショットへ行く現在のバージョンの修正ファイルに印を付けるという意味です.

これは Git プロジェクトの3主部門へ導きます. Git ディレクトリ, ワーク・ディレクトリ, ステージ・エリアです.

Insert 18333fig0106.png 
図 1-6. ワーク・ディレクトリ, ステージ・エリア, Git ディレクトリ

Git ディレクトリとは, Git がどこにプロジェクト用のメタデータとオブジェクトデータベースを格納するかです. これは Git の最も重要な部分で, 別のコンピュータからリポジトリをクローンした時何がコピーされるかです.

ワーク・ディレクトリとは, プロジェクト内のあるバージョンの単一チェックアウトです. これらファイルは Git ディレクトリの圧縮データベースから除かれて使用・編集のためディスク上に置かれたものです.

ステージ・エリアとは, 単純なファイルで, 通常 Git ディレクトリに格納されており, それは次のコミットに何が来るかについて情報を持っています. それは時々インデックスとして参照されますが, それをステージ・エリアとして参照するのが標準となってきています.

基本 Git ワークフローはこのようになります:

1. ワーク・ディレクトリのファイルを編集します.
2． ファイルをステージして, そのスナップショットをステージ・エリアに追加します.
3. コミットして, それはファイルをステージ・エリア内のものとして取り, Git ディレクトリへ恒久的にスナップショットを格納します. 

ファイルの特定のバージョンが Git ディレクトリにあるなら, コミットされたと考えられます. それが編集されているがステージ・エリアに追加されているなら, ステージされています. そしてそれがチェックアウトされステージされていない状態から変更されたなら, 編集されています. 第2章で, これら状態についてより多く学ぶでしょう. そしてそれらをどのように利用するかどのようにステージ部分を全て省略するか学ぶでしょう.

## Git のインストール ##

Git 使用に乗り込みましょう. 真っ先にやるべきは最も重要な事です. Git をインストールする必要があります. 複数の方法から1つ選ぶことが出来ます. 主流の2つはソースからインストールするかプラットフォーム向け既存パッケージをインストールするかです.

### ソースからインストール ###

出来れば, ソースから Git をインストールするのが通常は便利です. 何故なら最も最近のバージョンを入手するでしょうから. Git の各バージョンは便利な UI 付加を内包する傾向にあります. ですから最新バージョンを入手するのはソースからソフトウェアをコンパイルするのが気楽なら大抵最良の道筋です. 多くの Linux ディストリビューションはとても古いパッケージを内包している場合もあります. ですから更新頻度の高いディストリビューションかバックポートを使用しない限り, ソースからインストールするのが最良策かも知れません.

Git をインストールするため, 次に挙げる依存ライブラリが必要です: curl, zlib, openssl, expat, libiconv. 例えば, yum (Fedora 等) や apt-get (Debian 系システム) を使用しているなら, 全依存関係をインストールするのにこれらコマンドの1つを使えます:

	$ yum install curl-devel expat-devel gettext-devel \
	  openssl-devel zlib-devel

	$ apt-get install curl-devel expat-devel gettext-devel \
	  openssl-devel zlib-devel
	
全ての必要依存関係を入手した時, 続けて最新スナップショットを Git の Web サイトから取ってくることが出来ます:

	http://git-scm.com/download
	
そして, コンパイルしてインストールします:

	$ tar -zxf git-1.6.0.5.tar.gz
	$ cd git-1.6.0.5
	$ make prefix=/usr/local all
	$ sudo make prefix=/usr/local install

これが終わったら, Git 自身を介してアップデートを入手することも出来ます:

	$ git clone git://git.kernel.org/pub/scm/git/git.git
	
### Linux 上のインストール ###

Linux 上でバイナリインストーラを介して Git をインストールしたいなら, ディストリビューション付属の基本的なパッケージ管理ツールで通常出来ます. Fedora 上なら, yum を使えます:

	$ yum install git-core

もしくは Ubuntu のような Debian 系ディストリビューション上なら, apt-get を試して下さい:

	$ apt-get install git-core

### Mac 上のインストール ###

Mac 上で Git をインストールする2つの簡単な方法があります. 最も簡単なのはグラフィカル Git インストーラです. これは Google Code ページからダウンロード出来ます(図1-7参照):

	http://code.google.com/p/git-osx-installer

Insert 18333fig0107.png 
図1-7. Git OS X インストーラ

その他主要な方法は MacPorts (`http://www.macports.org`) を介してインストールする事です.

	$ sudo port install git-core +svn +doc +bash_completion +gitweb

余分なもの全てを追加する必要はありません. しかしおそらく +svn はいつか Subversion リポジトリで Git を使用する必要に備えて追加したいでしょう(8章参照).

### Windows 上のインストール ###

Windows 上の Git インストールはとても簡単です. msysGit プロジェクトはより簡単なインストール方法の1つです. 単に exe ファイルインストーラを Google Code ページよりダウンロードして, 走らせるだけです:

	http://code.google.com/p/msysgit

インストールされた後, コマンドラインバージョン(後々何かと便利な SSH クライアントを含んでいます)と標準 GUI の両方があります.

## Git の初期設定 ##

システム上に Git がある今, 幾らか Git 環境をカスタマイズしたいでしょう. これらの事は1度だけに留めるべきです. それらはアップグレード間をついて回ります. またいつでもコマンド実行する事でそれらを再度変更できます.

Git は git config というツールが付属しており, これは Git がどのように見え作用するするかの全局面を管理する構成値の取得と設定をします. これら構成値は3つの異なる場所に格納される可能性があります:

*	`/etc/gitconfig` ファイル: システム上の全ユーザとそれら全てのリポジトリの値を格納します. 具体的には, オプション ` --system` を `git config` に渡せば, このファイルから読み書きします.
*	`~/.gitconfig` ファイル: ユーザを特定します. `--global` オプションを渡す事で Git にこのファイルに特定して読み書きさせることができます.
*	現在作業中のリポジトリ内 git ディレクトリの config ファイル(つまり `.git/config`): 単一リポジトリを特定します. 各レベルがその前のレベル値を上書きします. つまり `.git/config` の値は `/etc/gitconfig` 内の値に勝ります.

Windows システム上で, Git は `$HOME` ディレクトリ内の `.gitconfig` ファイル(多くの場合は `C:\Documents and Settings\$USER`) を探します. また Msys ルートに関係のある /etc/config も探します. これはインストーラを実行するときに Windows 上のどこでも指定したインストール先です.

### あなたの ID ###

Git をインストールしたら最初にすべきはユーザ名とEメールアドレスの設定です. これは重要です. 何故なら毎回 Git コミットはこの情報を使い, 以下のように渡したコミットに不変的に焼き付けるからです:

	$ git config --global user.name "John Doe"
	$ git config --global user.email johndoe@example.com

もう1度, `--global` オプションを渡すなら1度きりにする必要があります. 何故なら Git は毎回その情報をそのシステム上でする全ての事に使うからです. 異なる名前やEメールアドレスを特定のプロジェクト用に上書きしたいなら, プロジェクト内にいる時 `--global` オプション抜きでコマンドを実行することが出来ます.

### あなたのエディタ ###

あなたの ID が設定された今, Git がメッセージを入力してほしい時に使用される標準のテキストエディタを設定できます. 標準では, Git はシステムの標準エディタを使用します. これは通常 Vi か Vim です. 異なるテキストエディタとして Emacs などを使いたいなら, 以下の通り出来ます:

	$ git config --global core.editor emacs
	
### あなたの Diff ツール ###

もう１つ便利なオプションで設定したい可能性があるのが merge 衝突の解決に使用する標準の Diff ツールです. vimdiff を使いたいなら:

	$ git config --global merge.tool vimdiff

Git は kdiff3, tkdiff, meld, xxdiff, emerge, vimdiff, gvimdiff, ecmerge, そして opendiff を有効な merge ツールとして受け入れます. またカスタムツールも設定できます. それをするより多くの情報のため第7章をご覧ください.

### 設定の確認 ###

設定を確認したいなら, その時点で Git が発見できる全設定をリスト化する `git config --list` コマンドを使えます:

	$ git config --list
	user.name=Scott Chacon
	user.email=schacon@gmail.com
	color.status=auto
	color.branch=auto
	color.interactive=auto
	color.diff=auto
	...

1つの設定事項に対して1度以上参照することがあります. 何故なら Git は 設定事項1つにつき複数のファイル(例えば `/etc/gitconfig` と `~/.gitconfig` 等)を読むからです. 上記の場合, Git は各々の設定事項が参照する最後の値を使用しています.

また Git が特定の設定事項の値が何であるか `git config {設定事項}` と入力することで確認できます:

	$ git config user.name
	Scott Chacon

## ヘルプの参照 ##

Git 使用中にヘルプが必要になった事があるなら, 全 Git コマンドのマニュアルページ (manpage) ヘルプを得る3つの方法があります:

	$ git help <verb>
	$ git <verb> --help
	$ man git-<verb>

例えば, config コマンドの manpage ヘルプを得るには以下を実行します:

	$ git help config

これらコマンドは親切です. 何故ならどこからでも, オフラインでさえもアクセス出来ます.
manpage やこの本が充分でなく人の助けが必要なら, Freenode IRC (irc.freenode.net) の `#git` や `#github` チャンネルを試してみることも可能です. これらチャンネルはたびたび Git に精通し大抵手助けの意志のある数百の人々で埋め尽くされます.

## まとめ ##

Git とは何かそして今まで使ってきたかも知れない CVCS とどう違うのかの基本的な理解をしたはずです. またあなた個人の ID を設定した Git が今システム上で動いているはずです. 今から Git 基礎学習の時間です.
=======
次に人々が遭遇した大きな問題は、他のシステムの開発者と共同制作をする必要があることです。この問題に対処するために、集中バージョン管理システム（CVCSs）が開発されました。CVSやSubversion、Perforceのような、これらのシステムは、全てのバージョン管理されたファイルと、その中央の場所からファイルをチェック・アウトする多数のクライアントを含む単一のサーバーを持ちます。長年の間、これはバージョン管理の標準となって来ました（図1-2参照）。

Insert 18333fig0102.png 
図1-2. 集中バージョン管理図解

この構成は、特にローカルVCSと比較して、多くの利点を提供します。例えば、全ての人は、プロジェクトのその他の全ての人々が何をしているのか、一定の程度は知っています。管理者は、誰が何をできるのかについて、きめ細かい統制手段を持ちます。このため、一つのCVCSを管理するということは、全てのクライアントのローカル・データベースを取り扱うより、はるかに容易です。

しかしながら、この構成はまた、深刻な不利益も持ちます。もっとも明白なのは、中央サーバーで発生する単一障害点です。もし、そのサーバーが1時間の間停止すると、その1時間の間は誰も全く、共同作業や、彼らが作業を進めている全てに対してバージョン変更の保存をすることができなくなります。もし中央データベースがのっているハードディスクが破損し、適切なバックアップが保持されていないとすると、人々が偶然にローカル・マシンに持っていた幾らかの単一スナップショット（訳者注：ある時点のファイル、ディレクトリなどの編集対象の状態）を除いた、プロジェクト全体の履歴を失うことになります。ローカルVCSシステムも、これと同じ問題に悩まされます。つまり、単一の場所にプロジェクトの全体の履歴を持っているときはいつでも、全てを失う事を覚悟することになります。

### 分散バージョン管理システム ###

ここから分散バージョン管理システム(DVCs)に入ります。DVCS(Git、Mercurial、Bazaar、Darcsのようなもの)では、クライアントはファイルの最新スナップショットをチェックアウト（訳者注：バージョン管理システムから、作業ディレクトリにファイルやディレクトリーをコピーすること）するだけではありません。リポジトリ（訳者注：バージョン管理の対象になるファイル、ディレクトリー、更新履歴などの一群）全体をミラーリングします。故にどのサーバが故障したとして、故障したサーバを介してそれらのDVCSが共同作業をしていたとしても、あらゆるクライアント・リポジトリーは修復のためにサーバーにコピーして戻す事ができます。そのサーバを介してコラボレーションしていたシステムは, どれか一つのクライアントのリポジトリからサーバ復旧の為バックアップをコピーすることができます. 全てのチェックアウトは、実は全データの完全バックアップなのです(図1-3を参照)。

Insert 18333fig0103.png 
図1-3. 分散バージョン管理システムの図解

そのうえ、これらのDVCSの多くは、 連携する複数のリモート・リポジトリを扱いながら大変よく機能するため、同一のプロジェクト内において、同時に異なった方法で、異なる人々のグループと共同作業が可能です。このことは、集中システムでは不可能であった階層モデルのような、幾つかの様式のワークフローを始めることを許します。

## Git略史 ##

人生における多くの素晴らしい出来事のように、Gitはわずかな創造的破壊と熱烈な論争から始まりました。Linuxカーネルは、非常に巨大な範囲のオープンソース・ソフトウェア・プロジェクトの一つです。Linuxカーネル保守の大部分の期間（1991-2002）の間は、このソフトウェアに対する変更は、パットとアーカイブしたファイルとして次々にまわされていました。2002年に、Linuxカーネル・プロジェクトはプロプライエタリのDVCSであるBitKeeperを使い始めました。

2005年に、Linuxカーネルを開発していたコミュニティーと、BitKeeperを開発していた営利企業との間の協力関係が崩壊しまし、課金無しの状態が取り消されました。これは、Linux開発コミュニティー（と、特にLinuxの作者のLinus Torvalds）に、BitKeeperを利用している間に学んだ幾つかの教訓を元に、彼ら独自のツールの開発を促しました。新しいシステムの目標の幾つかは、次の通りでした：

*	スピード
*	シンプルな設計
*	ノンリニア開発(数千の並列ブランチ)への強力なサポート
*	完全な分散
*	Linux カーネルのような大規模プロジェクトを(スピードとデータサイズで)効率的に取り扱い可能

2005年のその誕生から、Gitは使いやすく発展・成熟してきており、さらにその初期の品質を維持しています。とても高速で、巨大プロジェクトではとても効率的で、ノンリニア開発のためのすごい分岐システム（branching system）を備えています（第3章参照）。

## Gitの基本 ##

では、要するにGitとは何なのでしょうか。これは、Gitを吸収するには重要な節です。なぜならば、もしGitが何かを理解し、Gitがどうやって稼動しているかの根本を理解できれば、Gitを効果的に使う事が恐らくとても容易になるからです。
Gitを学ぶときは、SubversionやPerforceのような他のVCSsに関してあなたが恐らく知っていることは、意識しないでください。このツールを使うときに、ちょっとした混乱を回避することに役立ちます。Gitは、ユーザー・インターフェイスがとてもよく似ているのにも関わらず、それら他のシステムとは大きく異なって、情報を格納して取り扱います（訳者注：「取り扱う」の部分はthinksなので、「見なします」と訳す方が原語に近い）。これらの相違を理解する事は、Gitを扱っている間の混乱を、防いでくれるでしょう。

### スナップショットで、差分ではない ###

Gitと他のVCS (Subversionとその類を含む)の主要な相違は、Gitのデータについての考え方です。概念的には、他のシステムのほとんどは、情報をファイルを基本とした変更のリストとして格納します。これらのシステム（CVS、Subversion、Perforce、Bazaar等々）は、図1-4に描かれているように、システムが保持しているファイルの集合と、時間を通じてそれぞれのファイルに加えられた変更の情報を考えます。

Insert 18333fig0104.png 
図1-4. 他のシステムは、データをそれぞれのファイルの基本バージョンへの変更として格納する傾向があります。

Gitは、この方法ではデータを考えたり、格納しません。代わりに、Gitはデータをミニ・ファイルシステムのスナップショットの集合のように考えます。Gitで全てのコミット（訳注：commitとは変更を記録・保存するGitの操作。詳細は後の章を参照）をするとき、もしくはプロジェクトの状態を保存するとき、Gitは基本的に、その時の全てのファイルの状態のスナップショットを撮り（訳者注：意訳）、そのスナップショットへの参照を格納するのです。効率化のため、ファイルに変更が無い場合は、Gitはファイルを再格納せず、既に格納してある、以前の同一のファイルへのリンクを格納します。Gitは、むしろデータを図1-5のように考えます。

Insert 18333fig0105.png 
図1-5. Gitは時間を通じたプロジェクトのスナップショットとしてデータを格納します。

これが、Gitと類似の全ての他のVCSsとの間の重要な違いです。ほとんどの他のシステムが以前の世代から真似してきた、ほとんど全てのバージョン管理のやり方（訳者注：aspectを意訳）を、Gitに見直させます。これは、Gitを、単純にVCSと言うより、その上に組み込まれた幾つかの途方も無くパワフルなツールを備えたミニ・ファイルシステムにしています。このやり方でデータを考えることで得られる利益の幾つかを、第3章のGit branchingを扱ったときに探求します。

### ほとんど全ての操作がローカル ###

Gitのほとんどの操作は、ローカル・ファイルと操作する資源だけ必要とします。大体はネットワークの他のコンピューターからの情報は必要ではありません。ほとんどの操作がネットワーク遅延損失を伴うCVCSに慣れているのであれば、もっさりとしたCVCSに慣れているのであれば、このGitの速度は神業のように感じるでしょう（訳者注：直訳は「このGitの側面はスピードの神様がこの世のものとは思えない力でGitを祝福したと考えさせるでしょう」）。すぐそこのローカル・ディスクにプロジェクトの丸ごとの履歴を保持しているため、ほとんどの操作はほとんど即座に思えます。

例えば、プロジェクトの履歴を閲覧するために、Gitはサーバーに履歴を取得しに行って表示する必要がありません。直接にローカル・データベースからそれを読むだけです。これは、プロジェクトの履歴をほとんど即座に知るということです。もし、あるファイルの現在のバージョンと、そのファイルの1ヶ月前の間に導入された変更点を知りたいのであれば、Gitは、遠隔のサーバーに差分を計算するように問い合わせたり、ローカルで差分を計算するために遠隔サーバーからファイルの古いバージョンを持ってくる代わりに、1か月前のファイルを調べてローカルで差分の計算を行なえます。

これはまた、オフラインであるか、VPNから切り離されていたとしても、出来ない事は非常に少ないことを意味します。もし、飛行機もしくは列車にに乗ってちょっとした仕事をしたいとしても、アップロードするためにネットワーク接続し始めるまで、楽しくコミットできます。もし、帰宅してVPNクライアントを適切に作動させられないとしても、さらに作業ができます。多くの他のシステムでは、それらを行なう事は、不可能であるか苦痛です。例えばPerforceにおいては、サーバーに接続できないときは、多くの事が行なえません。SubversionとCVSにおいては、ファイルの編集はできますが、データベースに変更をコミットできません（なぜならば、データベースがオフラインだからです）。このことは巨大な問題でに思えないでしょうが、実に大きな違いを生じうることに驚くでしょう。

### Gitは完全性を持つ ###

Gitの全てのものは、格納される前にチェックサムが取られ、その後、そのチェックサムで照合されます。これは、Gitがそれに関して感知することなしに、あらゆるファイルの内容を変更することが不可能であることを意味します。この機能は、Gitの最下層に組み込まれ、またGitの哲学に不可欠です。Gitがそれを感知できない状態で、転送中に情報を失う、もしくは壊れたファイルを取得することはありません。

Gitがチェックサム生成に用いる機構は、SHA-1ハッシュと呼ばれます。これは、16進数の文字（0-9とa-f）で構成された40文字の文字列で、ファイルの内容もしくはGit内のディレクトリ構造を元に計算されます。SHA-1ハッシュは、このようなもののように見えます:

	24b9da6552252987aa493b52f8696cd6d3b00373

Gitはハッシュ値を大変よく利用するので、Gitのいたるところで、これらのハッシュ値を見ることでしょう。事実、Gitはファイル名ではなく、ファイル内容のハッシュ値によってアドレスが呼び出されるGitデータベースの中に全てを格納しています。

### Gitは通常はデータを追加するだけ ###

Gitで行動するとき、ほとんど全てはGitデータベースにデータを追加するだけです。システムにいかなる方法でも、UNDO不可能なこと、もしくはデータを消させることをさせるのは、大変難しいです。あらゆるVCSと同様に、まだコミットしていない変更は失ったり、台無しにできたりします。しかし、スナップショットをGitにコミットした後は、特にもし定期的にデータベースを他のリポジトリーにプッシュ（訳注：pushはGitで管理するあるリポジトリーのデータを、他のリポジトリーに転送する操作。詳細は後の章を参照）していれば、変更を失うことは大変難しくなります。

激しく物事をもみくちゃにする危険なしに試行錯誤を行なえるため、これはGitの利用を喜びに変えます。Gitがデータをどのように格納しているのかと失われたように思えるデータをどうやって回復できるのかについての、より詳細な解説に関しては、第9章の"Under the Covers"を参照してください。

### 三つの状態 ###

今、注意してください。もし学習プロセスの残りをスムーズに進めたいのであれば、これはGitに関して覚えておく主要な事です。Gitは、ファイルが帰属する、コミット済、修正済、ステージ済の、三つの主要な状態を持ちます。コミット済は、ローカル・データベースにデータが安全に格納されていることを意味します。修正済は、ファイルに変更を加えていますが、データベースにそれがまだコミットされていないことを意味します。ステージ済は、次のスナップショットのコミットに加えるために、現在のバージョンの修正されたファイルに印をつけている状態を意味します。

このことは、Gitプロジェクト（訳者注：ディレクトリ内）の、Gitディレクトリ、作業ディレクトリ、ステージング・エリアの三つの主要な部分（訳者注：の理解）に導きます。

Insert 18333fig0106.png 
図1-6. 作業ディレクトリ、ステージング・エリア、Gitディレクトリ

Gitディレクトリは、プロジェクトのためのメタデータ（訳者注：Gitが管理するファイルやディレクトリーなどのオブジェクトの要約）とオブジェクトのデータベースがあるところです。これは、Gitの最も重要な部分で、他のコンピューターからリポジトリーをクローン（訳者注：コピー元の情報を記録した状態で、Gitリポジトリーをコピーすること）したときに、コピーされるものです。

作業ディレクトリは、プロジェクトの一つのバージョンの単一チェックアウトです。これらのファイルはGitディレクトリーの圧縮されたデータベースから引き出されて、利用するか修正するためにディスクに配置されます。

ステージング・エリアは、普通はGitディレクトリに含まれる、次のコミットにﾅﾆが含まれるかに関しての情報を蓄えた一つの単純なファイルです。ときどきインデックスのように引き合いにだされますが、ステージング・エリアとして呼ばれることが基本になりつつあります。

基本的なGitのワークフローは、このような風に進みます：

1. 作業ディレクトリのファイルを修正します。
2. 修正されたファイルのスナップショットをステージング・エリアに追加して、ファイルをステージします。
3. コミットします。（訳者注：Gitでは）これは、ステージング・エリアにあるファイルを取得し、永久不変に保持するスナップショットとしてGitディレクトリに格納することです。

もしファイルの特定のバージョンがGitディレクトリの中にあるとしたら、コミット済だと見なされます。もし修正されていて、ステージング・エリアに加えられていれば、ステージ済です。そして、チェックアウトされてから変更されましたが、ステージされていないとするなら、修正済です。第2章では、これらの状態と、どうやってこれらを利用をするか、もしくは完全にステージ化部分を省略するかに関してより詳しく学習します。

## Gitのインストール ##

少しGitを使う事に入りましょう。何よりも最初に、Gitをインストールしなければなりません。幾つもの経路で入手することができ、主要な二つの方法のうちの一つはソースからインストールすることで、もう一つはプラットフォームに応じて存在するパッケージをインストールすることです。

### ソースからのインストール ###

もし可能であれば、もっとも最新のバージョンを入手できるので、一般的にソースからGitをインストールするのが便利です。Gitのそれぞれのバージョンは、実用的なユーザー・インターフェイスの向上が含まれており、もしソースからソフトウェアをコンパイルすることに違和感を感じないのであれば、最新バージョンを入手することは、大抵は最も良い経路になります。また、多くのLinuxディストリビューションがとても古いパッケージを収録している事は良くあることであり、最新のディストリビューションを使っているか、バックポート（訳者注：最新のパッケージを古いディストリビューションで使えるようにする事）をしていない限りは、ソースからのインストールがベストな選択になるでしょう。

Gitをインストールするためには、Gitが依存するライブラリーである、curl、zlib、openssl、expat、libiconvを入手する必要があります。例えば、もし（Fedoraなどで）yumか（Debianベースのシステムなどで）apt-getが入ったシステムを使っているのであれば、これらのコマンドの一つを依存対象の全てをインストールするのに使う事ができます：

	$ yum install curl-devel expat-devel gettext-devel \
	  openssl-devel zlib-devel

	$ apt-get install curl-devel expat-devel gettext-devel \
	  openssl-devel zlib-devel
	
全ての必要な依存対象を持っているのであれば、先に進んでGitのウェブサイトから最新版のスナップショットを持ってくる事ができます：

	http://git-scm.com/download
	
そして、コンパイルしてインストールします：

	$ tar -zxf git-1.6.0.5.tar.gz
	$ cd git-1.6.0.5
	$ make prefix=/usr/local all
	$ sudo make prefix=/usr/local install

また、Gitのインストール後、アップデートでGitを通して最新版のGitを得ることができます。

	$ git clone git://git.kernel.org/pub/scm/git/git.git
	
### Linuxにインストール ###

バイナリのインストーラーを通じてLinux上にGitをインストールしたいのであれば、大抵はディストリビューションに付属する基本的なパッケージ・マネジメント・ツールを使って、それを行なう事ができます。もしFedoraを使っているのであれば、yumを使う事が出来ます：

	$ yum install git-core

もしくは、もしUbuntuのようなDebianベースのディストリュビューションを使っているのであれば、apt-getをやってみましょう：

	$ apt-get install git-core

### Macにインストール ###

MacにGitをインストールするには2つの簡単な方法があります。もっとも簡単な方法は、グラフィカルなGitインストーラーを使うことで、このGitインストーラーはGoogle Codeのページ（図1-7参照）からダウンロードすることができます：

	http://code.google.com/p/git-osx-installer

Insert 18333fig0107.png 
Figure 1-7. Git OS X installer

もう一つの主要な方法は、MacPorts (`http://www.macports.org`) からGitをインストールすることです。MacPortsをインストールした状態であれば、Gitを以下のようにインストールできます。

	$ sudo port install git-core +svn +doc +bash_completion +gitweb

全てのvariantsを追加する必要はありませんが、SubversionのリポジトリーでGitを使う必要がまだあるなら、恐らく+svnを含めないといけないでしょう（第8章参照）。

### Windowsにインストール ###

WindowsにGitをインストールするのはとても簡単です。msysGitプロジェクトは、より簡単なインストール手続きの一つを備えています。Google Codeのページから、単純にインストーラーのexeファイルをダウンロードをし、実行してください：

	http://code.google.com/p/msysgit

インストール後、コマンドライン版（後で役に立つSSHクライアントを含む）とスタンダードGUI版の両方を使う事ができます。

## 最初のGitの構成 ##

今や、Gitがシステムにあります。Git環境をカスタマイズするためにしたい事が少しはあることでしょう。アップグレードの度についてまわるので、たった一度でそれらを終わらすべきでしょう。またそれらは、またコマンドを実行することによっていつでも変更することができます。

Gitには、git configと呼ばれるツールが付属します。これで、どのようにGitが見えて機能するかの全ての面を制御できる設定変数を取得し、設定することができます。これらの変数は三つの異なる場所に格納されうります：

*	`/etc/gitconfig` file: システム上の全てのユーザーと全てのリポジトリーに対する設定値を保持します。もし`--system`オプションを`git config`に指定すると、明確にこのファイルに読み書きを行ないます。
*	`~/.gitconfig` file: 特定のユーザーに対する設定値を保持します. `--global`オプションを指定することで、Gitに、明確にこのファイルに読み書きを行なわせることができます。
*	現在使っている、あらゆるリポジトリのGitディレクトリーの設定ファイル(`.git/config`のことです): 特定の単一リポジトリーに対する設定値を保持します。それぞれのレベルの値は以前のレベルの値を上書きするため、`.git/config`の中の設定値は`/etc/gitconfig`の設定値に優先されます。

Windows環境下では、Gitは`$HOME`ディレクトリ（ほとんどのユーザーは`C:\Documents and Settings\$USER`)（訳者注：環境変数`USERPROFILE`で指定される）の中の`.gitconfig`ファイルを検索に行きます。また、インストーラー時にWidnowsシステムにGitをインストールすると決めたところにある、MSysのルートとの相対位置であったとしても、/etc/gitconfigも見に行きます。

### 個人の識別情報 ###

Gitをインストールしたときに最初にすべきことは、ユーザー名とE-mailアドレスを設定することです。全てのGitのコミットはこの情報を用いるため、これは重要で、次々とまわすコミットに永続的に焼き付けられます：

	$ git config --global user.name "John Doe"
	$ git config --global user.email johndoe@example.com

また、もし`--global`オプションを指定するのであれば、Gitはその後、そのシステム上で行なう（訳者注：あるユーザーの）全ての操作に対して常にこの情報を使うようになるため、この操作を行なう必要はたった一度だけです。もし、違う名前とE-mailアドレスを特定のプロジェクトで上書きしたいのであれば、そのプロジェクトの（訳者注：Gitディレクトリーの）中で、`--global`オプション無しでこのコマンドを実行することができます。

### エディター ###

今や、個人の識別情報が設定され、Gitがメッセージのタイプをさせる必要があるときに使う、標準のテキストエディターを設定できます。標準では、Gitはシステムのデフォルト・エディターを使います。これは大抵の場合、ViかVimです。Emacsのような違うテキスト・エディターを使いたい場合は、次のようにします：

	$ git config --global core.editor emacs
	
### diffツール ###

設定したいと思われる、その他の便利なオプションは、マージ（訳者注：複数のリポジトリーを併合すること）時の衝突を解決するために使う、標準のdiffツールです。vimdiffを使いたいとします：

	$ git config --global merge.tool vimdiff

Gitはkdiff3、tkdiff、meld、xxdiff、emerge、vimdiff、gvimdiff、ecmerge、opendiffを確かなマージ・ツールとして扱えます。カスタム・ツールもまた設定できますが、これをする事に関しての詳細な情報は第7章を参照してください。

### 設定の確認 ###

設定を確認したい場合は、その時点でGitが見つけられる全ての設定を一覧するコマンドである`git config --list`を使う事ができます：

	$ git config --list
	user.name=Scott Chacon
	user.email=schacon@gmail.com
	color.status=auto
	color.branch=auto
	color.interactive=auto
	color.diff=auto
	...

Gitは異なったファイル(例えば`/etc/gitconfig`と`~/.gitconfig`)から同一のキーを読み込むため、同一のキーを1度以上見ることになるでしょう。この場合、Gitは見つけたそれぞれ同一のキーに対して最後の値を用います。

また、Gitに設定されている特定のキーの値を、`git config {key}`をタイプすることで確認することができます：

	$ git config user.name
	Scott Chacon

## ヘルプを見る ##

もし、Gitを使っている間は助けがいつも必要なら、あらゆるGitコマンドのヘルプのマニュアル・ページ（manpage）を参照する3種類の方法があります。

	$ git help <verb>
	$ git <verb> --help
	$ man git-<verb>

例えば、configコマンドのヘルプのmanpageを次のコマンドを走らせることで見ることができます。

	$ git help config

これらのコマンドは、オフラインのときでさえ、どこでも見る事ができるので、すばらしいです。
もしmanpageとこの本が十分でなく、人の助けが必要であれば、フリーノードIRCサーバー（irc.freenode.net）の`#git`もしくは`#github`チャンネルにアクセスしてみてください。これらのチャンネルはいつも、全員がGitに関してとても知識があり、よく助けてくれようとする数百人の人々でいっぱいです。

## おわりに ##

Gitとは何か、どのように今まで使われてきた他のCVCSと異なるのかについて、基本的な理解ができたはずです。また、今や個人情報の設定ができた、システムに稼動するバージョンのGitがあるはずです。今や、本格的にGitの基本を学習するときです。
>>>>>>> dbd964a02caf3fb3f3d379a54b0be9197eeb8c1b
